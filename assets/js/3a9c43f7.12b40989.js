"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6415],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||a;return n?o.createElement(h,i(i({ref:t},d),{},{components:n})):o.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4280:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(7462),r=(n(7294),n(3905));const a={},i="Memento",s={unversionedId:"design_patterns/behavior_design_patterns/memento",id:"design_patterns/behavior_design_patterns/memento",title:"Memento",description:"In software development, you may have scenarios where you need to capture and restore an object's internal state without exposing its details. For example, consider a text editor where you want to implement undo/redo functionality. Without the Memento Pattern, you might need to expose the entire state of the editor, leading to tight coupling and a lack of encapsulation.",source:"@site/docs/design_patterns/behavior_design_patterns/memento.md",sourceDirName:"design_patterns/behavior_design_patterns",slug:"/design_patterns/behavior_design_patterns/memento",permalink:"/docs/design_patterns/behavior_design_patterns/memento",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/behavior_design_patterns/memento.md",tags:[],version:"current",lastUpdatedBy:"sieuhuflit",lastUpdatedAt:1693756320,formattedLastUpdatedAt:"Sep 3, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Mediator",permalink:"/docs/design_patterns/behavior_design_patterns/mediator"},next:{title:"Observer",permalink:"/docs/design_patterns/behavior_design_patterns/observer"}},l={},c=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"memento"},"Memento"),(0,r.kt)("h1",{id:"problem"},"Problem"),(0,r.kt)("admonition",{title:"The Memento Pattern Problem:",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"In software development, you may have scenarios where you need to capture and restore an object's internal state without exposing its details. For example, consider a text editor where you want to implement undo/redo functionality. Without the Memento Pattern, you might need to expose the entire state of the editor, leading to tight coupling and a lack of encapsulation."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Problem: Implementing undo/redo functionality without the Memento Pattern\n\nclass TextEditor {\n  constructor() {\n    this.content = "";\n  }\n\n  type(text) {\n    this.content += text;\n  }\n\n  deleteLastCharacter() {\n    this.content = this.content.slice(0, -1);\n  }\n}\n\n// Client code managing undo/redo manually\nconst editor = new TextEditor();\neditor.type("Hello, ");\nconsole.log("Content after typing: ", editor.content);\n\neditor.type("world!");\nconsole.log("Content after typing more: ", editor.content);\n\neditor.deleteLastCharacter();\nconsole.log("Content after deleting: ", editor.content);\n\n// Manually maintaining a history for undo/redo\nconst history = [];\nhistory.push(editor.content); // Save the current state\n\n// Restoring previous state\neditor.content = history.pop();\nconsole.log("Content after undo: ", editor.content);\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code, the text editor directly manages its content, and the client code manually maintains a history to implement undo/redo functionality. This approach exposes the internal state of the editor and lacks encapsulation.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("admonition",{title:"The Memento Pattern Solution:",type:"success"},(0,r.kt)("p",{parentName:"admonition"},"The Memento Pattern provides a way to capture an object's internal state and externalize it, allowing the object to be restored to that state at a later time. It involves three key components: the originator (the object whose state needs to be saved), the memento (a snapshot of the state), and the caretaker (responsible for storing and retrieving mementos). This pattern promotes encapsulation and allows for easy undo/redo functionality."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Solution: Implementing undo/redo functionality using the Memento Pattern\n\nclass Memento {\n  constructor(content) {\n    this.content = content;\n  }\n}\n\nclass TextEditor {\n  constructor() {\n    this.content = "";\n  }\n\n  type(text) {\n    this.content += text;\n  }\n\n  deleteLastCharacter() {\n    this.content = this.content.slice(0, -1);\n  }\n\n  save() {\n    return new Memento(this.content);\n  }\n\n  restore(memento) {\n    this.content = memento.content;\n  }\n}\n\nclass EditorHistory {\n  constructor() {\n    this.history = [];\n  }\n\n  push(memento) {\n    this.history.push(memento);\n  }\n\n  pop() {\n    return this.history.pop();\n  }\n}\n\n// Client code using the Memento Pattern for undo/redo\nconst editor = new TextEditor();\nconst history = new EditorHistory();\n\neditor.type("Hello, ");\nconsole.log("Content after typing: ", editor.content);\n\nhistory.push(editor.save()); // Save the current state\n\neditor.type("world!");\nconsole.log("Content after typing more: ", editor.content);\n\neditor.deleteLastCharacter();\nconsole.log("Content after deleting: ", editor.content);\n\n// Restoring previous state (undo)\nconst previousState = history.pop();\nif (previousState) {\n  editor.restore(previousState);\n  console.log("Content after undo: ", editor.content);\n} else {\n  console.log("No more undo steps available.");\n}\n\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code with the Memento Pattern:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"We introduce a Memento class to represent the snapshot of the editor's content."),(0,r.kt)("li",{parentName:"ul"},"The TextEditor class provides methods to save and restore the state using mementos."),(0,r.kt)("li",{parentName:"ul"},"The EditorHistory class manages a history of mementos, enabling undo/redo functionality.")),(0,r.kt)("p",{parentName:"admonition"},"The Memento Pattern encapsulates the state of the TextEditor object and allows for easy undo/redo functionality without exposing the internal state. It is particularly useful when you need to capture and restore an object's state or implement undo/redo in an application.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"when-to-use"},"When to Use"),(0,r.kt)("p",null,"When to Use the Memento Pattern:\nYou should consider using the Memento Pattern in the following situations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When you need to capture and restore the internal state of an object without exposing its details."),(0,r.kt)("li",{parentName:"ol"},"When you want to implement undo/redo functionality in an application."),(0,r.kt)("li",{parentName:"ol"},"When you want to ensure that the object's state is encapsulated and not directly accessible by other objects."),(0,r.kt)("li",{parentName:"ol"},"When you need to maintain a history of changes to an object's state.")))}u.isMDXComponent=!0}}]);