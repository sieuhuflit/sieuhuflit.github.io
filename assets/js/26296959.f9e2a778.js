"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5721],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,f=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return n?i.createElement(f,r(r({ref:t},d),{},{components:n})):i.createElement(f,r({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3571:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={},r="Chain of responsibility",s={unversionedId:"design_patterns/behavior_design_patterns/chain_of_responsibility",id:"design_patterns/behavior_design_patterns/chain_of_responsibility",title:"Chain of responsibility",description:"In software development, you may have scenarios where multiple objects need to process a request or perform some action, but you don't want to hardcode the specific handling order or make the client code aware of all possible handlers. Traditional approaches involve tight coupling between the client and the handling logic, leading to inflexible code.",source:"@site/docs/design_patterns/behavior_design_patterns/chain_of_responsibility.md",sourceDirName:"design_patterns/behavior_design_patterns",slug:"/design_patterns/behavior_design_patterns/chain_of_responsibility",permalink:"/docs/design_patterns/behavior_design_patterns/chain_of_responsibility",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/behavior_design_patterns/chain_of_responsibility.md",tags:[],version:"current",lastUpdatedBy:"Sieu Thai",lastUpdatedAt:1696996042,formattedLastUpdatedAt:"Oct 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Behavior Design Patterns",permalink:"/docs/category/behavior-design-patterns"},next:{title:"Command",permalink:"/docs/design_patterns/behavior_design_patterns/command"}},l={},c=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"chain-of-responsibility"},"Chain of responsibility"),(0,a.kt)("h1",{id:"problem"},"Problem"),(0,a.kt)("admonition",{title:"The Chain of Responsibility Pattern Problem:",type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"In software development, you may have scenarios where multiple objects need to process a request or perform some action, but you don't want to hardcode the specific handling order or make the client code aware of all possible handlers. Traditional approaches involve tight coupling between the client and the handling logic, leading to inflexible code."),(0,a.kt)("p",{parentName:"admonition"},"For example, consider a situation where you have a series of validators to check user input. Without the Chain of Responsibility Pattern, you might need to explicitly call each validator in a specific order in the client code, which can be cumbersome and inflexible."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// Problem: Handling user input validation without the Chain of Responsibility Pattern\n\nclass InputValidator {\n  constructor() {}\n\n  validate(input) {\n    // Validation logic\n    if (!input) {\n      return "Input cannot be empty.";\n    }\n    return null;\n  }\n}\n\nclass LengthValidator {\n  constructor() {}\n\n  validate(input) {\n    // Validation logic\n    if (input.length < 8) {\n      return "Input must be at least 8 characters long.";\n    }\n    return null;\n  }\n}\n\n// Client code with explicit validation order\nconst input = "password";\nconst inputValidator = new InputValidator();\nconst lengthValidator = new LengthValidator();\n\nconst inputError = inputValidator.validate(input);\nconst lengthError = lengthValidator.validate(input);\n\nif (inputError) {\n  console.log("Input error:", inputError);\n} else if (lengthError) {\n  console.log("Length error:", lengthError);\n} else {\n  console.log("Input is valid.");\n}\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code, we have two validation classes (InputValidator and LengthValidator). The client code explicitly calls these validators in a specific order to validate user input, resulting in tightly coupled code.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"solution"},"Solution"),(0,a.kt)("admonition",{title:"The Chain of Responsibility Pattern Solution:",type:"success"},(0,a.kt)("p",{parentName:"admonition"},"The Chain of Responsibility Pattern addresses this issue by creating a chain of handler objects, each responsible for processing a specific type of request. Each handler has a reference to the next handler in the chain. When a request is made, it's passed along the chain until a handler can process it. This allows for flexible, decoupled, and extensible handling logic."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// Solution: Using the Chain of Responsibility Pattern for input validation\n\nclass Validator {\n  constructor(successor = null) {\n    this.successor = successor;\n  }\n\n  setSuccessor(successor) {\n    this.successor = successor;\n  }\n\n  validate(input) {\n    const error = this._validate(input);\n    if (error === null && this.successor) {\n      return this.successor.validate(input);\n    }\n    return error;\n  }\n\n  _validate(input) {\n    // To be implemented by concrete validators\n    return null;\n  }\n}\n\nclass InputValidator extends Validator {\n  _validate(input) {\n    if (!input) {\n      return "Input cannot be empty.";\n    }\n    return null;\n  }\n}\n\nclass LengthValidator extends Validator {\n  _validate(input) {\n    if (input.length < 8) {\n      return "Input must be at least 8 characters long.";\n    }\n    return null;\n  }\n}\n\n// Client code with a chain of validators\nconst input = "password";\nconst inputValidator = new InputValidator();\nconst lengthValidator = new LengthValidator();\n\ninputValidator.setSuccessor(lengthValidator);\n\nconst error = inputValidator.validate(input);\n\nif (error) {\n  console.log("Validation error:", error);\n} else {\n  console.log("Input is valid.");\n}\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code with the Chain of Responsibility Pattern:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"We create a base Validator class that defines the chain of responsibility logic."),(0,a.kt)("li",{parentName:"ul"},"Concrete validator classes (InputValidator and LengthValidator) extend the Validator class and implement the _validate method."),(0,a.kt)("li",{parentName:"ul"},"The client code sets up a chain of validators and invokes the validation process, allowing each validator to check and pass the request to the next in the chain if needed."))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"when-to-use"},"When to Use"),(0,a.kt)("p",null,"When to Use the Chain of Responsibility Pattern:\nYou should consider using the Chain of Responsibility Pattern in the following situations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When you have a series of objects that need to process requests or perform actions in a specific order."),(0,a.kt)("li",{parentName:"ol"},"When you want to decouple the sender (client) of a request from its receivers (handlers)."),(0,a.kt)("li",{parentName:"ol"},"When you want to add new handlers or change the order of processing without modifying existing client code."),(0,a.kt)("li",{parentName:"ol"},"When you want to avoid hardcoding the handling logic and make it more flexible and extensible.")))}u.isMDXComponent=!0}}]);