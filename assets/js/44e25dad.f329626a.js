"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8633],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,g=h["".concat(l,".").concat(u)]||h[u]||p[u]||o;return n?i.createElement(g,a(a({ref:t},d),{},{components:n})):i.createElement(g,a({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),r=(n(7294),n(3905));const o={},a="Visitor",s={unversionedId:"design_patterns/behavior_design_patterns/visitor",id:"design_patterns/behavior_design_patterns/visitor",title:"Visitor",description:"In software development, you may have a complex object structure with multiple types of elements or nodes. When you need to perform various operations on these elements, adding new operations or behaviors to the elements can become challenging, especially if the element classes are scattered throughout your codebase. Without the Visitor Pattern, you might resort to using multiple conditional statements (e.g., using instanceof) to apply different behaviors to different types of elements, resulting in code that is hard to maintain and extend.",source:"@site/docs/design_patterns/behavior_design_patterns/visitor.md",sourceDirName:"design_patterns/behavior_design_patterns",slug:"/design_patterns/behavior_design_patterns/visitor",permalink:"/docs/design_patterns/behavior_design_patterns/visitor",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/behavior_design_patterns/visitor.md",tags:[],version:"current",lastUpdatedBy:"Sieu Thai",lastUpdatedAt:1696998432,formattedLastUpdatedAt:"Oct 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Template method",permalink:"/docs/design_patterns/behavior_design_patterns/template_method"},next:{title:"Creational Design Patterns",permalink:"/docs/category/creational-design-patterns"}},l={},c=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],d={toc:c},h="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"visitor"},"Visitor"),(0,r.kt)("h1",{id:"problem"},"Problem"),(0,r.kt)("admonition",{title:"The Visitor Pattern Problem:",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"In software development, you may have a complex object structure with multiple types of elements or nodes. When you need to perform various operations on these elements, adding new operations or behaviors to the elements can become challenging, especially if the element classes are scattered throughout your codebase. Without the Visitor Pattern, you might resort to using multiple conditional statements (e.g., using instanceof) to apply different behaviors to different types of elements, resulting in code that is hard to maintain and extend."),(0,r.kt)("p",{parentName:"admonition"},"For example, consider a system with different shapes (e.g., circles, squares, triangles) that need to be rendered and printed. Without the Visitor Pattern, you might have to add rendering and printing logic directly into each shape class."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Problem: Implementing rendering and printing for shapes without the Visitor Pattern\n\nclass Circle {\n  constructor(radius) {\n    this.radius = radius;\n  }\n\n  render() {\n    console.log(`Rendered a circle with radius ${this.radius}.`);\n  }\n\n  print() {\n    console.log(`Printed a circle with radius ${this.radius}.`);\n  }\n}\n\nclass Square {\n  constructor(side) {\n    this.side = side;\n  }\n\n  render() {\n    console.log(`Rendered a square with side length ${this.side}.`);\n  }\n\n  print() {\n    console.log(`Printed a square with side length ${this.side}.`);\n  }\n}\n\nclass Triangle {\n  constructor(base, height) {\n    this.base = base;\n    this.height = height;\n  }\n\n  render() {\n    console.log(`Rendered a triangle with base ${this.base} and height ${this.height}.`);\n  }\n\n  print() {\n    console.log(`Printed a triangle with base ${this.base} and height ${this.height}.`);\n  }\n}\n\n// Client code\nconst shapes = [new Circle(5), new Square(4), new Triangle(3, 6)];\n\nfor (const shape of shapes) {\n  shape.render();\n  shape.print();\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"In this code, rendering and printing logic is directly implemented in each shape class, leading to code duplication and making it difficult to add new behaviors without modifying the shape classes.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("admonition",{title:"The Visitor Pattern Solution:",type:"success"},(0,r.kt)("p",{parentName:"admonition"},"The Visitor Pattern allows you to define a separate visitor class for each operation or behavior that you want to apply to elements in an object structure. Elements (objects) accept visitors, and the visitors perform the desired operations on the elements. This pattern promotes flexibility by allowing you to add new operations (visitor classes) without modifying the element classes."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Solution: Implementing rendering and printing for shapes using the Visitor Pattern\n\nclass Circle {\n  constructor(radius) {\n    this.radius = radius;\n  }\n\n  accept(visitor) {\n    visitor.visitCircle(this);\n  }\n}\n\nclass Square {\n  constructor(side) {\n    this.side = side;\n  }\n\n  accept(visitor) {\n    visitor.visitSquare(this);\n  }\n}\n\nclass Triangle {\n  constructor(base, height) {\n    this.base = base;\n    this.height = height;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangle(this);\n  }\n}\n\nclass Renderer {\n  visitCircle(circle) {\n    console.log(`Rendered a circle with radius ${circle.radius}.`);\n  }\n\n  visitSquare(square) {\n    console.log(`Rendered a square with side length ${square.side}.`);\n  }\n\n  visitTriangle(triangle) {\n    console.log(`Rendered a triangle with base ${triangle.base} and height ${triangle.height}.`);\n  }\n}\n\nclass Printer {\n  visitCircle(circle) {\n    console.log(`Printed a circle with radius ${circle.radius}.`);\n  }\n\n  visitSquare(square) {\n    console.log(`Printed a square with side length ${square.side}.`);\n  }\n\n  visitTriangle(triangle) {\n    console.log(`Printed a triangle with base ${triangle.base} and height ${triangle.height}.`);\n  }\n}\n\n// Client code using the Visitor Pattern\nconst shapes = [new Circle(5), new Square(4), new Triangle(3, 6)];\nconst renderer = new Renderer();\nconst printer = new Printer();\n\nfor (const shape of shapes) {\n  shape.accept(renderer); // Render each shape\n  shape.accept(printer); // Print each shape\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"In this code with the Visitor Pattern:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"We define separate visitor classes (Renderer and Printer) for rendering and printing behaviors."),(0,r.kt)("li",{parentName:"ul"},"Each shape class (Circle, Square, Triangle) accepts a visitor and delegates the rendering or printing operation to the visitor."),(0,r.kt)("li",{parentName:"ul"},"The client code uses visitors to apply rendering and printing behaviors to shapes without modifying the shape classes.")),(0,r.kt)("p",{parentName:"admonition"},"The Visitor Pattern separates the algorithm (visitor) from the elements it operates on, promoting flexibility and making it easy to add new behaviors without changing the element classes. It is useful when you have complex object structures with multiple types of elements and need to perform various operations on them.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"when-to-use"},"When to Use"),(0,r.kt)("p",null,"When to Use the Visitor Pattern:\nYou should consider using the Visitor Pattern in the following situations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When you have a complex object structure with multiple types of elements or nodes, and you want to perform various operations on them without modifying their classes."),(0,r.kt)("li",{parentName:"ol"},"When you want to add new operations or behaviors to elements without changing their code."),(0,r.kt)("li",{parentName:"ol"},"When you need to separate the algorithm (visitor) from the elements it operates on, promoting a clean separation of concerns."),(0,r.kt)("li",{parentName:"ol"},"When you want to avoid using conditional statements to apply different behaviors to different types of elements.")))}p.isMDXComponent=!0}}]);