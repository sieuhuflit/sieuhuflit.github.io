"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2756],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,f=m["".concat(l,".").concat(u)]||m[u]||c[u]||o;return n?r.createElement(f,i(i({ref:t},d),{},{components:n})):r.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={tags:["Arrays"]},i="Sweet And Savory",s={unversionedId:"medium/sweet_and_savory",id:"medium/sweet_and_savory",title:"Sweet And Savory",description:"You're hosting an event at a food festival and want to showcase the best possible pairing of two dishes from the festival that complement each other's flavor profile.",source:"@site/docs/medium/sweet_and_savory.md",sourceDirName:"medium",slug:"/medium/sweet_and_savory",permalink:"/docs/medium/sweet_and_savory",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/medium/sweet_and_savory.md",tags:[{label:"Arrays",permalink:"/docs/tags/arrays"}],version:"current",lastUpdatedBy:"sieuhuflit",lastUpdatedAt:1693756320,formattedLastUpdatedAt:"Sep 3, 2023",frontMatter:{tags:["Arrays"]},sidebar:"tutorialSidebar",previous:{title:"Suffix Trie Construction",permalink:"/docs/medium/suffix_trie_construction"},next:{title:"Symmetrical Tree",permalink:"/docs/medium/symetrical_tree"}},l={},p=[],d={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"sweet-and-savory"},"Sweet And Savory"),(0,a.kt)("admonition",{title:"Sweet And Savory",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You're hosting an event at a food festival and want to showcase the best possible pairing of two dishes from the festival that complement each other's flavor profile."),(0,a.kt)("p",{parentName:"admonition"},"Each dish has a flavor profile represented by an integer. A negative integer means a dish is sweet, while a positive integer means a dish is savory. The absolute value of that integer represents the intensity of that flavor. For example, a flavor profile of -3 is slightly sweet, one of -10 is extremely sweet, one of 2 is mildly savory, and one of 8 is significantly savory."),(0,a.kt)("p",{parentName:"admonition"},"You're given an array of these dishes and a target combined flavor profile. Write a function that returns the best possible pairing of two dishes (the pairing with a total flavor profile that's closest to the target one). Note that this pairing must include one sweet and one savory dish. You're also concerned about the dish being too savory, so your pairing should never be more savory than the target flavor profile."),(0,a.kt)("p",{parentName:"admonition"},"All dishes will have a positive or negative flavor profile; there are no dishes with a 0 value. For simplicity, you can assume that there will be at most one best solution. If there isn't a valid solution, your function should return ","[0, 0]",". The returned array should be sorted, meaning the sweet dish should always come first."),(0,a.kt)("p",{parentName:"admonition"},"Sample Input #1"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"dishes = [-3, -5, 1, 7]   \ntarget = 8\n")),(0,a.kt)("p",{parentName:"admonition"},"Sample Output #1"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"[-3, 7] // The combined profile of 4 is closest without going over\n")),(0,a.kt)("p",{parentName:"admonition"},"Sample Input #2"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"dishes = [3, 5, 7, 2, 6, 8, 1]  \ntarget = 10\n")),(0,a.kt)("p",{parentName:"admonition"},"Sample Output #2"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"[0, 0] // There are no sweet dishes\n")),(0,a.kt)("p",{parentName:"admonition"},"Sample Input #3"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"dishes = [2, 5, -4, -7, 12, 100, -25]  \ntarget = -20\n")),(0,a.kt)("p",{parentName:"admonition"},"Sample Output #3"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"[-25, 5] // This pairing gets the exact combined profile of -20\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Solution 1"',title:'"Solution','1"':!0},"// O(n * log(n)) time | O(n) space - where n is number of dishes\nfunction sweetAndSavory(dishes, target) {\n  const sweetDishes = dishes.filter(dish => dish < 0).sort((a, b) => b - a);\n  const savoryDishes = dishes.filter(dish => dish > 0).sort((a, b) => a - b);\n\n  let bestPair = [0, 0];\n  let bestDifference = Infinity;\n  let sweetIndex = 0,\n    savoryIndex = 0;\n\n  while (sweetIndex < sweetDishes.length && savoryIndex < savoryDishes.length) {\n    const currentSum = sweetDishes[sweetIndex] + savoryDishes[savoryIndex];\n\n    if (currentSum <= target) {\n      const currentDifference = target - currentSum;\n      if (currentDifference < bestDifference) {\n        bestDifference = currentDifference;\n        bestPair = [sweetDishes[sweetIndex], savoryDishes[savoryIndex]];\n      }\n      savoryIndex += 1;\n    } else {\n      sweetIndex += 1;\n    }\n  }\n\n  return bestPair;\n}\n")))}c.isMDXComponent=!0}}]);