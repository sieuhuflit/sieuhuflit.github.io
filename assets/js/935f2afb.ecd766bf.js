"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Intro","href":"/docs/intro","docId":"intro"},{"type":"category","label":"Medium","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Binary Tree Diameter","href":"/docs/medium/binary_tree_diameter","docId":"medium/binary_tree_diameter"},{"type":"link","label":"Find Successor","href":"/docs/medium/find_successtor","docId":"medium/find_successtor"},{"type":"link","label":"Height Balanced Binary Tree","href":"/docs/medium/height_balanced_binary_tree","docId":"medium/height_balanced_binary_tree"},{"type":"link","label":"Kadane\'s Algorithm","href":"/docs/medium/kadanes_algorithm","docId":"medium/kadanes_algorithm"},{"type":"link","label":"Levenshtein Distance","href":"/docs/medium/levenshtein_distance","docId":"medium/levenshtein_distance"},{"type":"link","label":"Max Subset Sum No Adjacent","href":"/docs/medium/max_subset_sum_no_adjadent","docId":"medium/max_subset_sum_no_adjadent"},{"type":"link","label":"Min Number Of Coins For Change","href":"/docs/medium/min_number_of_coins_for_change","docId":"medium/min_number_of_coins_for_change"},{"type":"link","label":"Number Of Ways To Make Change","href":"/docs/medium/number_of_ways_to_make_change","docId":"medium/number_of_ways_to_make_change"},{"type":"link","label":"Symmetrical Tree","href":"/docs/medium/symetrical_tree","docId":"medium/symetrical_tree"}],"href":"/docs/category/medium"}]},"docs":{"intro":{"id":"intro","title":"Intro","description":"","sidebar":"tutorialSidebar"},"medium/binary_tree_diameter":{"id":"medium/binary_tree_diameter","title":"Binary Tree Diameter","description":"Write a function that takes in a Binary Tree and returns its diameter. The diameter of a binary tree is defined as the length of its longest path, even if that path doesn\'t pass through the root of the tree.","sidebar":"tutorialSidebar"},"medium/find_successtor":{"id":"medium/find_successtor","title":"Find Successor","description":"Write a function that takes in a Binary Tree (where nodes have an additional pointer to their parent node) as well as a node contained in that tree and returns the given node\'s successor.","sidebar":"tutorialSidebar"},"medium/height_balanced_binary_tree":{"id":"medium/height_balanced_binary_tree","title":"Height Balanced Binary Tree","description":"You\'re given the root node of a Binary Tree. Write a function that returns true if this Binary Tree is height balanced and false if it isn\'t.","sidebar":"tutorialSidebar"},"medium/kadanes_algorithm":{"id":"medium/kadanes_algorithm","title":"Kadane\'s Algorithm","description":"Write a function that takes in a non-empty array of integers and returns the maximum sum that can be obtained by summing up all of the integers in a non-empty subarray of the input array. A subarray must only contain adjacent numbers (numbers next to each other in the input array).","sidebar":"tutorialSidebar"},"medium/levenshtein_distance":{"id":"medium/levenshtein_distance","title":"Levenshtein Distance","description":"Write a function that takes in two strings and returns the minimum number of edit operations that need to be performed on the first string to obtain the second string.","sidebar":"tutorialSidebar"},"medium/max_subset_sum_no_adjadent":{"id":"medium/max_subset_sum_no_adjadent","title":"Max Subset Sum No Adjacent","description":"Write a function that takes in an array of positive integers and returns the maximum sum of non-adjacent elements in the array.","sidebar":"tutorialSidebar"},"medium/min_number_of_coins_for_change":{"id":"medium/min_number_of_coins_for_change","title":"Min Number Of Coins For Change","description":"Given an array of positive integers representing coin denominations and a single non-negative integer n representing a target amount of money, write a function that returns the smallest number of coins needed to make change for (to sum up to) that target amount using the given coin denominations.","sidebar":"tutorialSidebar"},"medium/number_of_ways_to_make_change":{"id":"medium/number_of_ways_to_make_change","title":"Number Of Ways To Make Change","description":"Given an array of distinct positive integers representing coin denominations and a single non-negative integer n representing a target amount of money, write a function that returns the number of ways to make change for that target amount using the given coin denominations.","sidebar":"tutorialSidebar"},"medium/symetrical_tree":{"id":"medium/symetrical_tree","title":"Symmetrical Tree","description":"Write a function that takes in a Binary Tree and returns if that tree is symmetrical. A tree is symmetrical if the left and right subtrees are mirror images of each other.","sidebar":"tutorialSidebar"}}}')}}]);