"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7277],{3905:(e,t,n)=>{n.d(t,{Zo:()=>f,kt:()=>g});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},f=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,f=s(e,["components","mdxType","originalType","parentName"]),d=l(n),p=r,g=d["".concat(c,".").concat(p)]||d[p]||u[p]||a;return n?o.createElement(g,i(i({ref:t},f),{},{components:n})):o.createElement(g,i({ref:t},f))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const a={},i="Decorator \ud83c\udfa8",s={unversionedId:"design_patterns/structure_design_patterns/decorator",id:"design_patterns/structure_design_patterns/decorator",title:"Decorator \ud83c\udfa8",description:"In software development, you may need to add behavior or responsibilities to individual objects dynamically, without affecting other objects of the same class. Traditional inheritance-based approaches involve creating a large number of subclasses for each combination of behaviors, leading to a class explosion and inflexibility.",source:"@site/docs/design_patterns/structure_design_patterns/decorator.md",sourceDirName:"design_patterns/structure_design_patterns",slug:"/design_patterns/structure_design_patterns/decorator",permalink:"/docs/design_patterns/structure_design_patterns/decorator",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/structure_design_patterns/decorator.md",tags:[],version:"current",lastUpdatedBy:"Sieu Thai",lastUpdatedAt:1696997789,formattedLastUpdatedAt:"Oct 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Composite",permalink:"/docs/design_patterns/structure_design_patterns/composite"},next:{title:"Facade",permalink:"/docs/design_patterns/structure_design_patterns/facade"}},c={},l=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],f={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"decorator-"},"Decorator \ud83c\udfa8"),(0,r.kt)("h1",{id:"problem"},"Problem"),(0,r.kt)("admonition",{title:"The Decorator Pattern Problem:",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"In software development, you may need to add behavior or responsibilities to individual objects dynamically, without affecting other objects of the same class. Traditional inheritance-based approaches involve creating a large number of subclasses for each combination of behaviors, leading to a class explosion and inflexibility."),(0,r.kt)("p",{parentName:"admonition"},"For example, consider a scenario where you have a Coffee class, and you want to add additional options like milk, sugar, or caramel to a coffee order. Without the Decorator Pattern, you might need to create subclasses for each possible combination, which is impractical."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Problem: Adding options to a coffee order without the Decorator Pattern\n\nclass Coffee {\n  constructor() {\n    this.cost = 5;\n    this.ingredients = ["Coffee"];\n  }\n\n  getCost() {\n    return this.cost;\n  }\n\n  getIngredients() {\n    return this.ingredients;\n  }\n}\n\n// Creating a coffee order with additional options\nconst coffeeWithMilk = new Coffee();\ncoffeeWithMilk.cost += 2;\ncoffeeWithMilk.ingredients.push("Milk");\n\nconst coffeeWithSugar = new Coffee();\ncoffeeWithSugar.cost += 1;\ncoffeeWithSugar.ingredients.push("Sugar");\n\nconsole.log("Coffee with Milk: ", coffeeWithMilk.getCost(), coffeeWithMilk.getIngredients());\nconsole.log("Coffee with Sugar: ", coffeeWithSugar.getCost(), coffeeWithSugar.getIngredients());\n\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code, we attempt to add options (e.g., milk, sugar) to a coffee order by directly modifying the Coffee class. This approach is inflexible and can lead to code that is hard to maintain, especially as the number of options increases.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("admonition",{title:"The Decorator Pattern Solution:",type:"success"},(0,r.kt)("p",{parentName:"admonition"},"The Decorator Pattern allows you to attach additional behaviors or responsibilities to objects dynamically. It involves creating a set of decorator classes that wrap the base object (component) and provide additional functionality without modifying the original class. Decorators follow the same interface as the component they decorate, making them interchangeable."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Solution: Using the Decorator Pattern to add options to a coffee order\n\n// Component: Coffee\nclass Coffee {\n  getCost() {\n    return 5;\n  }\n\n  getIngredients() {\n    return "Coffee";\n  }\n}\n\n// Decorator: Milk\nclass MilkDecorator {\n  constructor(coffee) {\n    this.coffee = coffee;\n  }\n\n  getCost() {\n    return this.coffee.getCost() + 2;\n  }\n\n  getIngredients() {\n    return `${this.coffee.getIngredients()}, Milk`;\n  }\n}\n\n// Decorator: Sugar\nclass SugarDecorator {\n  constructor(coffee) {\n    this.coffee = coffee;\n  }\n\n  getCost() {\n    return this.coffee.getCost() + 1;\n  }\n\n  getIngredients() {\n    return `${this.coffee.getIngredients()}, Sugar`;\n  }\n}\n\n// Creating a coffee order with decorators\nlet coffee = new Coffee();\nconsole.log("Plain Coffee: ", coffee.getCost(), coffee.getIngredients());\n\ncoffee = new MilkDecorator(coffee);\nconsole.log("Coffee with Milk: ", coffee.getCost(), coffee.getIngredients());\n\ncoffee = new SugarDecorator(coffee);\nconsole.log("Coffee with Milk and Sugar: ", coffee.getCost(), coffee.getIngredients());\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code with the Decorator Pattern:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"We have a base class Coffee representing the component with a default cost and ingredients."),(0,r.kt)("li",{parentName:"ul"},"We create decorator classes (MilkDecorator and SugarDecorator) that wrap the base Coffee class and add additional behavior (cost and ingredients) to it."),(0,r.kt)("li",{parentName:"ul"},"The decorators follow the same interface as the component, making them interchangeable and allowing us to stack them to create different combinations of options."))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"when-to-use"},"When to Use"),(0,r.kt)("p",null,"When to Use the Decorator Pattern:\nYou should consider using the Decorator Pattern in the following situations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When you need to add behavior or responsibilities to individual objects dynamically and without modifying their class."),(0,r.kt)("li",{parentName:"ol"},"When you want to avoid creating a large number of subclasses to represent different combinations of behaviors."),(0,r.kt)("li",{parentName:"ol"},"When you want to keep the original class (component) and the decorator classes open for extension but closed for modification."),(0,r.kt)("li",{parentName:"ol"},"When you need to compose objects with different combinations of behaviors.")))}u.isMDXComponent=!0}}]);