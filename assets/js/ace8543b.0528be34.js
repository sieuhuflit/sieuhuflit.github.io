"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8268],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),l=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),h=l(a),m=r,u=h["".concat(s,".").concat(m)]||h[m]||p[m]||o;return a?n.createElement(u,c(c({ref:t},d),{},{components:a})):n.createElement(u,c({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,c=new Array(o);c[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[h]="string"==typeof e?e:r,c[1]=i;for(var l=2;l<o;l++)c[l]=a[l];return n.createElement.apply(null,c)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7355:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=a(7462),r=(a(7294),a(3905));const o={},c="Factory method \ud83c\udfed",i={unversionedId:"design_patterns/creational_design_patterns/factory_method",id:"design_patterns/creational_design_patterns/factory_method",title:"Factory method \ud83c\udfed",description:"In software design, you often encounter scenarios where you need to create objects of different types, but you want to abstract away the details of object creation from the client code. Directly instantiating objects using new can lead to tight coupling between the client code and the classes being instantiated, making it challenging to introduce new classes or change existing ones.",source:"@site/docs/design_patterns/creational_design_patterns/factory_method.md",sourceDirName:"design_patterns/creational_design_patterns",slug:"/design_patterns/creational_design_patterns/factory_method",permalink:"/docs/design_patterns/creational_design_patterns/factory_method",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/creational_design_patterns/factory_method.md",tags:[],version:"current",lastUpdatedBy:"Sieu Thai",lastUpdatedAt:1696996042,formattedLastUpdatedAt:"Oct 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Builder \ud83c\udfd7\ufe0f",permalink:"/docs/design_patterns/creational_design_patterns/builder"},next:{title:"Prototype \ud83e\uddec",permalink:"/docs/design_patterns/creational_design_patterns/prototype"}},s={},l=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],d={toc:l},h="wrapper";function p(e){let{components:t,...a}=e;return(0,r.kt)(h,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"factory-method-"},"Factory method \ud83c\udfed"),(0,r.kt)("h1",{id:"problem"},"Problem"),(0,r.kt)("admonition",{title:"Problem",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"In software design, you often encounter scenarios where you need to create objects of different types, but you want to abstract away the details of object creation from the client code. Directly instantiating objects using new can lead to tight coupling between the client code and the classes being instantiated, making it challenging to introduce new classes or change existing ones."),(0,r.kt)("p",{parentName:"admonition"},"For example, imagine you're building a game and need to create various types of characters, like wizards, warriors, and archers. If you directly create these characters in your game code, it becomes difficult to extend the game with new character types or change the implementation of existing characters without modifying the client code."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Problem: Creating characters without Factory Method\n\n// Character classes\nclass Wizard {\n  constructor(name) {\n    this.name = name;\n    this.type = "Wizard";\n  }\n\n  attack() {\n    console.log(`${this.name} casts a spell.`);\n  }\n}\n\nclass Warrior {\n  constructor(name) {\n    this.name = name;\n    this.type = "Warrior";\n  }\n\n  attack() {\n    console.log(`${this.name} swings a sword.`);\n  }\n}\n\nclass Archer {\n  constructor(name) {\n    this.name = name;\n    this.type = "Archer";\n  }\n\n  attack() {\n    console.log(`${this.name} shoots an arrow.`);\n  }\n}\n\n// Game code\nconst player1 = new Wizard("Gandalf");\nconst player2 = new Warrior("Aragorn");\n\nplayer1.attack(); // Output: Gandalf casts a spell.\nplayer2.attack(); // Output: Aragorn swings a sword.\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code, we have three character classes (Wizard, Warrior, and Archer). The game code directly creates instances of these classes based on the player's choice. While this approach works, it has several drawbacks:"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"1. Tight Coupling"),": The client code is tightly coupled to the specific character classes. If you want to add a new character type or modify the existing ones, you need to modify the client code, potentially introducing bugs or breaking existing functionality."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"2. Scalability Issues"),": As the game grows, maintaining and extending the codebase becomes challenging. Adding new character types requires modifying the client code, which can lead to code that's difficult to manage and prone to errors."),(0,r.kt)("p",{parentName:"admonition"},"To address these issues, we can implement the Factory Method Pattern, as shown in the previous example, to decouple the client code from the concrete character classes and make it easier to extend the game with new character types.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("admonition",{title:"Factory Pattern Solution",type:"success"},(0,r.kt)("p",{parentName:"admonition"},"The Factory Method Pattern addresses the object creation problem by defining an interface (or abstract class) for creating objects, but allowing subclasses to decide the actual class to instantiate. It abstracts the process of object creation, promoting loose coupling between the client code and the classes being created. This way, you can add new classes (new types of objects) without modifying the existing client code."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Solution: Using Factory Method Pattern\n\n// Step 1: Define the Creator (CharacterFactory)\nclass CharacterFactory {\n  createCharacter(name) {\n    throw new Error("Subclasses must implement createCharacter method.");\n  }\n}\n\n// Step 2: Create Concrete Creators (WizardFactory, WarriorFactory, ArcherFactory)\nclass WizardFactory extends CharacterFactory {\n  createCharacter(name) {\n    return new Wizard(name);\n  }\n}\n\nclass WarriorFactory extends CharacterFactory {\n  createCharacter(name) {\n    return new Warrior(name);\n  }\n}\n\nclass ArcherFactory extends CharacterFactory {\n  createCharacter(name) {\n    return new Archer(name);\n  }\n}\n\n// Character classes remain the same\nclass Wizard {\n  constructor(name) {\n    this.name = name;\n    this.type = "Wizard";\n  }\n\n  attack() {\n    console.log(`${this.name} casts a spell.`);\n  }\n}\n\nclass Warrior {\n  constructor(name) {\n    this.name = name;\n    this.type = "Warrior";\n  }\n\n  attack() {\n    console.log(`${this.name} swings a sword.`);\n  }\n}\n\nclass Archer {\n  constructor(name) {\n    this.name = name;\n    this.type = "Archer";\n  }\n\n  attack() {\n    console.log(`${this.name} shoots an arrow.`);\n  }\n}\n\n// Game code\nfunction createCharacterAndAttack(factory, playerName) {\n  const character = factory.createCharacter(playerName);\n  character.attack();\n}\n\nconst wizardFactory = new WizardFactory();\nconst warriorFactory = new WarriorFactory();\nconst archerFactory = new ArcherFactory();\n\ncreateCharacterAndAttack(wizardFactory, "Gandalf"); // Output: Gandalf casts a spell.\ncreateCharacterAndAttack(warriorFactory, "Aragorn"); // Output: Aragorn swings a sword.\ncreateCharacterAndAttack(archerFactory, "Legolas"); // Output: Legolas shoots an arrow.\n')),(0,r.kt)("p",{parentName:"admonition"},"In this code, we've implemented the Factory Method Pattern:"),(0,r.kt)("p",{parentName:"admonition"},"We have a CharacterFactory abstract class (Creator) with a createCharacter method that must be implemented by concrete factories."),(0,r.kt)("p",{parentName:"admonition"},"We create three concrete factories: WizardFactory, WarriorFactory, and ArcherFactory. Each factory implements the createCharacter method to create specific character instances."),(0,r.kt)("p",{parentName:"admonition"},"The game code uses the createCharacterAndAttack function, which takes a factory and a player name. It creates a character using the factory and then calls the attack method on the created character."),(0,r.kt)("p",{parentName:"admonition"},"With this pattern, adding new character types is as simple as creating a new factory class and implementing the createCharacter method for that type, without modifying the client code. This promotes extensibility and maintainability in your game code.")),(0,r.kt)("h2",{id:"when-to-use"},"When to Use"),(0,r.kt)("p",null,"When to Use the Factory Method Pattern:\nYou should consider using the Factory Method Pattern in the following situations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When you want to delegate the responsibility of object creation to subclasses."),(0,r.kt)("li",{parentName:"ol"},"When you need to create objects based on different conditions or configurations."),(0,r.kt)("li",{parentName:"ol"},"When you want to ensure that the client code remains decoupled from the concrete classes being created."),(0,r.kt)("li",{parentName:"ol"},"When you need to extend the system with new classes without modifying existing code.")),(0,r.kt)("p",null,"The Factory Method Pattern is especially useful when you have a family of related classes or when you anticipate changes in the types of objects to be created in the future."))}p.isMDXComponent=!0}}]);