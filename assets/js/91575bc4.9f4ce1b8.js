"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7658],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=a,h=p["".concat(c,".").concat(m)]||p[m]||u[m]||o;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=n(7462),a=(n(7294),n(3905));const o={},i="Abstract factory",s={unversionedId:"design_patterns/creational_design_patterns/abstract_factory",id:"design_patterns/creational_design_patterns/abstract_factory",title:"Abstract factory",description:"In some complex systems, you may need to create families of related objects that have compatible interfaces. For instance, in a graphical user interface (GUI) framework, you might need to create various UI components like buttons, text fields, and checkboxes. Each component has a different appearance and behavior, and these components must be consistent within the same theme (e.g., dark mode or light mode).",source:"@site/docs/design_patterns/creational_design_patterns/abstract_factory.md",sourceDirName:"design_patterns/creational_design_patterns",slug:"/design_patterns/creational_design_patterns/abstract_factory",permalink:"/docs/design_patterns/creational_design_patterns/abstract_factory",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/creational_design_patterns/abstract_factory.md",tags:[],version:"current",lastUpdatedBy:"sieuhuflit",lastUpdatedAt:1693755323,formattedLastUpdatedAt:"Sep 3, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Creational Design Patterns",permalink:"/docs/category/creational-design-patterns"},next:{title:"Builder",permalink:"/docs/design_patterns/creational_design_patterns/builder"}},c={},d=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],l={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"abstract-factory"},"Abstract factory"),(0,a.kt)("h1",{id:"problem"},"Problem"),(0,a.kt)("admonition",{title:"Problem",type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"In some complex systems, you may need to create families of related objects that have compatible interfaces. For instance, in a graphical user interface (GUI) framework, you might need to create various UI components like buttons, text fields, and checkboxes. Each component has a different appearance and behavior, and these components must be consistent within the same theme (e.g., dark mode or light mode)."),(0,a.kt)("p",{parentName:"admonition"},"Without the Abstract Factory Pattern, you might end up with code that directly creates these components without considering the theme, leading to UI elements that don't match. Additionally, if you want to switch themes or add new components, you'll need to make changes in multiple places throughout the codebase."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import React from \'react\';\n\n// Without Pattern: Creating themed UI components directly\n\n// Light theme components\nconst LightButton = () => (\n  <button className="light-button">Light Button</button>\n);\n\nconst LightTextField = () => (\n  <input type="text" className="light-text-field" placeholder="Light Text Field" />\n);\n\n// Dark theme components\nconst DarkButton = () => (\n  <button className="dark-button">Dark Button</button>\n);\n\nconst DarkTextField = () => (\n  <input type="text" className="dark-text-field" placeholder="Dark Text Field" />\n);\n\n// Themed UI component\nconst ThemedUI = ({ theme }) => {\n  return (\n    <div>\n      {theme === \'light\' ? (\n        <div>\n          <LightButton />\n          <LightTextField />\n        </div>\n      ) : (\n        <div>\n          <DarkButton />\n          <DarkTextField />\n        </div>\n      )}\n    </div>\n  );\n};\n\n// App component\nfunction App() {\n  return (\n    <div>\n      <h1>Themed UI Components Without Pattern</h1>\n      <ThemedUI theme="light" />\n      <ThemedUI theme="dark" />\n    </div>\n  );\n}\n\nexport default App;\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code, we create UI components (buttons and text fields) without considering the theme. This leads to inconsistent UI rendering, especially when switching themes or adding new components.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"solution"},"Solution"),(0,a.kt)("admonition",{title:"Factory Pattern Solution",type:"success"},(0,a.kt)("p",{parentName:"admonition"},"The Factory Method Pattern addresses the object creation problem by defining an interface (or abstract class) for creating objects, but allowing subclasses to decide the actual class to instantiate. It abstracts the process of object creation, promoting loose coupling between the client code and the classes being created. This way, you can add new classes (new types of objects) without modifying the existing client code."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import React, { Component } from \'react\';\n\n// Step 1: Define Abstract Factory (UIFactory)\nclass UIFactory {\n  createButton() {\n    throw new Error("Subclasses must implement createButton method.");\n  }\n\n  createTextField() {\n    throw new Error("Subclasses must implement createTextField method.");\n  }\n}\n\n// Step 2: Create Concrete Factories (LightUIFactory and DarkUIFactory)\nclass LightUIFactory extends UIFactory {\n  createButton() {\n    return <LightButton />;\n  }\n\n  createTextField() {\n    return <LightTextField />;\n  }\n}\n\nclass DarkUIFactory extends UIFactory {\n  createButton() {\n    return <DarkButton />;\n  }\n\n  createTextField() {\n    return <DarkTextField />;\n  }\n}\n\n// Step 3: Define Abstract Products (Button and TextField)\nclass Button extends Component {\n  render() {\n    throw new Error("Subclasses must implement render method.");\n  }\n}\n\nclass TextField extends Component {\n  render() {\n    throw new Error("Subclasses must implement render method.");\n  }\n}\n\n// Step 4: Create Concrete Products (LightButton, DarkButton, LightTextField, DarkTextField)\nclass LightButton extends Button {\n  render() {\n    return <button className="light-button">Light Button</button>;\n  }\n}\n\nclass DarkButton extends Button {\n  render() {\n    return <button className="dark-button">Dark Button</button>;\n  }\n}\n\nclass LightTextField extends TextField {\n  render() {\n    return <input type="text" className="light-text-field" placeholder="Light Text Field" />;\n  }\n}\n\nclass DarkTextField extends TextField {\n  render() {\n    return <input type="text" className="dark-text-field" placeholder="Dark Text Field" />;\n  }\n}\n\n// Step 5: Create a Themed UI Component\nclass ThemedUI extends Component {\n  constructor(props) {\n    super(props);\n    this.factory = props.theme === \'light\' ? new LightUIFactory() : new DarkUIFactory();\n  }\n\n  render() {\n    const button = this.factory.createButton();\n    const textField = this.factory.createTextField();\n\n    return (\n      <div>\n        {button}\n        {textField}\n      </div>\n    );\n  }\n}\n\n// App component\nfunction App() {\n  return (\n    <div>\n      <h1>Themed UI Components with Abstract Factory Pattern</h1>\n      <ThemedUI theme="light" />\n      <ThemedUI theme="dark" />\n    </div>\n  );\n}\n\nexport default App;\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code, we've applied the Abstract Factory Pattern to create themed UI components. The Abstract Factory ensures that the created components are consistent with the chosen theme, and it allows for easy addition of new themes or components in the future. The ThemedUI component selects the appropriate factory based on the theme prop.")),(0,a.kt)("h2",{id:"when-to-use"},"When to Use"),(0,a.kt)("p",null,"You should consider using the Abstract Factory Pattern in the following situations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When your system needs to create families of related or dependent objects."),(0,a.kt)("li",{parentName:"ol"},"When you want to ensure that the created objects are consistent and compatible with each other, such as in theme-based UI components."),(0,a.kt)("li",{parentName:"ol"},"When you need to provide an interface for creating objects without specifying their concrete classes."),(0,a.kt)("li",{parentName:"ol"},"When you want to support multiple product families with the ability to add new families easily.")))}u.isMDXComponent=!0}}]);