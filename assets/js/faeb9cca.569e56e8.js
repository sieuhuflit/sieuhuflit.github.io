"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2809],{3905:(t,e,n)=>{n.d(e,{Zo:()=>g,kt:()=>m});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var l=r.createContext({}),c=function(t){var e=r.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},g=function(t){var e=c(t.components);return r.createElement(l.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,o=t.originalType,l=t.parentName,g=s(t,["components","mdxType","originalType","parentName"]),p=c(n),d=a,m=p["".concat(l,".").concat(d)]||p[d]||u[d]||o;return n?r.createElement(m,i(i({ref:e},g),{},{components:n})):r.createElement(m,i({ref:e},g))}));function m(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s[p]="string"==typeof t?t:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5426:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={},i="Strategy \ud83c\udfaf",s={unversionedId:"design_patterns/behavior_design_patterns/strategy",id:"design_patterns/behavior_design_patterns/strategy",title:"Strategy \ud83c\udfaf",description:"In software development, you may need to implement different algorithms or behaviors for a particular task. Without the Strategy Pattern, you might end up with conditional statements to select the appropriate algorithm based on specific conditions. This approach leads to code that is difficult to maintain, inflexible, and tightly coupled to the algorithms.",source:"@site/docs/design_patterns/behavior_design_patterns/strategy.md",sourceDirName:"design_patterns/behavior_design_patterns",slug:"/design_patterns/behavior_design_patterns/strategy",permalink:"/docs/design_patterns/behavior_design_patterns/strategy",draft:!1,editUrl:"https://github.com/sieuhuflit/sieuhuflit.github.io/tree/main/docs/design_patterns/behavior_design_patterns/strategy.md",tags:[],version:"current",lastUpdatedBy:"Sieu Thai",lastUpdatedAt:1696997789,formattedLastUpdatedAt:"Oct 11, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"State",permalink:"/docs/design_patterns/behavior_design_patterns/state"},next:{title:"Template method",permalink:"/docs/design_patterns/behavior_design_patterns/template_method"}},l={},c=[{value:"Solution",id:"solution",level:2},{value:"When to Use",id:"when-to-use",level:2}],g={toc:c},p="wrapper";function u(t){let{components:e,...n}=t;return(0,a.kt)(p,(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"strategy-"},"Strategy \ud83c\udfaf"),(0,a.kt)("h1",{id:"problem"},"Problem"),(0,a.kt)("admonition",{title:"The Strategy Pattern Problem:",type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"In software development, you may need to implement different algorithms or behaviors for a particular task. Without the Strategy Pattern, you might end up with conditional statements to select the appropriate algorithm based on specific conditions. This approach leads to code that is difficult to maintain, inflexible, and tightly coupled to the algorithms."),(0,a.kt)("p",{parentName:"admonition"},"For example, consider a sorting algorithm that needs to be flexible enough to switch between various sorting methods (e.g., bubble sort, merge sort, quicksort). Without the Strategy Pattern, you might use if-else statements to choose the sorting algorithm, making the code complex and less extensible."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// Problem: Implementing sorting algorithms without the Strategy Pattern\n\nfunction bubbleSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        // Swap elements\n        const temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n}\n\nfunction mergeSort(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  // Implementation of merge sort\n  // ...\n}\n\n// Client code selecting and using sorting algorithms\nconst unsortedArray = [5, 2, 9, 1, 5, 6];\n\n// Conditionally choose a sorting algorithm\nconst useBubbleSort = true;\n\nif (useBubbleSort) {\n  bubbleSort(unsortedArray);\n} else {\n  mergeSort(unsortedArray);\n}\n\nconsole.log("Sorted array:", unsortedArray);\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code, the client code directly selects and uses sorting algorithms based on conditional statements (if-else), resulting in tight coupling between the client and the algorithms.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"solution"},"Solution"),(0,a.kt)("admonition",{title:"The Strategy Pattern Solution:",type:"success"},(0,a.kt)("p",{parentName:"admonition"},"The Strategy Pattern defines a family of interchangeable algorithms, encapsulates each algorithm in a separate class (strategy), and allows clients to choose and switch between these strategies at runtime. It promotes flexibility, encapsulation, and clean separation of concerns."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// Solution: Implementing sorting algorithms using the Strategy Pattern\n\nclass BubbleSort {\n  sort(arr) {\n    const n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          // Swap elements\n          const temp = arr[j];\n          arr[j] = arr[j + 1];\n          arr[j + 1] = temp;\n        }\n      }\n    }\n  }\n}\n\nclass MergeSort {\n  sort(arr) {\n    if (arr.length <= 1) {\n      return arr;\n    }\n\n    // Implementation of merge sort\n    // ...\n  }\n}\n\nclass SortingContext {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  sort(arr) {\n    this.strategy.sort(arr);\n  }\n}\n\n// Client code using the Strategy Pattern\nconst unsortedArray = [5, 2, 9, 1, 5, 6];\n\nconst bubbleSort = new BubbleSort();\nconst mergeSort = new MergeSort();\n\nconst sortingContext = new SortingContext(bubbleSort);\n\nsortingContext.sort(unsortedArray);\n\nconsole.log("Sorted array using bubble sort:", unsortedArray);\n\nsortingContext.setStrategy(mergeSort);\nsortingContext.sort(unsortedArray);\n\nconsole.log("Sorted array using merge sort:", unsortedArray);\n')),(0,a.kt)("p",{parentName:"admonition"},"In this code with the Strategy Pattern:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"We define separate strategy classes (BubbleSort, MergeSort) for each sorting algorithm, encapsulating their behavior."),(0,a.kt)("li",{parentName:"ul"},"The SortingContext class allows the client to set and switch between sorting strategies at runtime."),(0,a.kt)("li",{parentName:"ul"},"Client code interacts with the SortingContext and delegates the sorting operation to the selected strategy.")),(0,a.kt)("p",{parentName:"admonition"},"The Strategy Pattern promotes cleaner separation of concerns, encapsulation of algorithms, and easy switching between strategies at runtime. It is particularly useful when you have multiple interchangeable algorithms or behaviors and want to avoid conditional statements to determine behavior.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"when-to-use"},"When to Use"),(0,a.kt)("p",null,"When to Use the Strategy Pattern:\nYou should consider using the Strategy Pattern in the following situations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When you have multiple algorithms or behaviors that need to be used interchangeably."),(0,a.kt)("li",{parentName:"ol"},"When you want to encapsulate each algorithm in its own class, making it easy to add or modify algorithms."),(0,a.kt)("li",{parentName:"ol"},"When you need to select and switch between algorithms at runtime."),(0,a.kt)("li",{parentName:"ol"},"When you want to avoid conditional statements that determine behavior.")))}u.isMDXComponent=!0}}]);